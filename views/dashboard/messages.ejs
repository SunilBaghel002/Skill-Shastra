<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>User Messages | Skill Shastra</title>
    <meta
      name="description"
      content="User messaging interface for Skill Shastra."
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <link
      rel="shortcut icon"
      href="/images/Logo_Black_Bg-2.png"
      type="image/x-icon"
    />
    <link rel="stylesheet" href="/css/styles.css" />
    <link rel="stylesheet" href="/css/sidebar.css" />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Poppins", sans-serif;
        background: #f3f4f6;
        margin-left: 280px;
        transition: margin-left 0.3s ease;
        max-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        overflow-x: hidden;
      }

      .main-content {
        margin-left: 0;
        width: 100%;
        overflow-y: auto;
        max-height: 100vh;
      }

      .chat-container {
        width: 100%;
        height: 100vh;
        background: #ffffff;
        border-radius: 0px;
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.15);
        display: flex;
        flex-direction: row;
      }

      .user-list-container {
        width: 33.33%;
        height: 100%;
        background: #f9fafb;
        border-right: 1px solid #e5e7eb;
        border-radius: 16px 0 0 16px;
        display: flex;
        flex-direction: column;
      }

      .user-list-header {
        padding: 1.5rem;
        border-bottom: 1px solid #e5e7eb;
      }

      .user-list-header h2 {
        font-size: 1.5rem;
        font-weight: 700;
        color: #1f2937;
      }

      .search-container {
        padding: 0.5rem 1.5rem;
      }

      .search-input {
        width: 100%;
        padding: 0.75rem;
        border: 1px solid #e5e7eb;
        border-radius: 9999px;
        font-size: 0.875rem;
        outline: none;
      }

      .search-input:focus {
        border-color: #4f46e5;
        box-shadow: 0 0 0 2px #818cf8;
      }

      .category-tabs {
        display: flex;
        border-bottom: 1px solid #e5e7eb;
        padding: 0.5rem 1.5rem;
      }

      .category-tab {
        flex: 1;
        text-align: center;
        padding: 0.5rem;
        font-size: 0.875rem;
        font-weight: 600;
        color: #6b7280;
        cursor: pointer;
        transition: color 0.2s, background 0.2s;
      }

      .category-tab.active {
        color: #4f46e5;
        border-bottom: 2px solid #4f46e5;
      }

      .category-tab:hover {
        color: #4338ca;
      }

      .user-list {
        flex: 1;
        min-height: 0;
        overflow-y: auto;
      }

      .user-item {
        display: flex;
        align-items: center;
        padding: 1rem;
        cursor: pointer;
        border-bottom: 1px solid #e5e7eb;
        transition: background 0.2s;
        position: relative;
      }

      .user-item:hover {
        background: #f3f4f6;
      }

      .user-item.selected {
        background: #e0e7ff;
      }

      .user-item img {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        margin-right: 1rem;
      }

      .user-item .user-info {
        flex: 1;
      }

      .user-item h3 {
        font-size: 1rem;
        font-weight: 600;
        color: #111827;
      }

      .user-item p {
        font-size: 0.875rem;
        color: #6b7280;
      }

      .user-item .message-time {
        font-size: 0.75rem;
        color: #6b7280;
        margin-left: auto;
      }

      .user-item .unread-count {
        margin-left: 0.5rem;
        background: #3b82f6;
        color: #ffffff;
        font-size: 0.75rem;
        font-weight: 700;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .user-item .favorite-btn {
        background: none;
        border: none;
        font-size: 1rem;
        color: #6b7280;
        cursor: pointer;
        margin-left: 0.5rem;
      }

      .user-item .favorite-btn.favorite {
        color: #eab308;
      }

      .user-item .call-btn {
        background: #4f46e5;
        color: #ffffff;
        border: none;
        border-radius: 4px;
        padding: 0.25rem 0.5rem;
        font-size: 0.75rem;
        cursor: pointer;
        margin-left: 0.5rem;
      }

      .user-item .call-btn:hover {
        background: #4338ca;
      }

      .chat-window-container {
        width: 66.67%;
        height: 100%;
        display: flex;
        flex-direction: column;
      }

      .chat-header {
        padding: 1rem;
        border-bottom: 1px solid #e5e7eb;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .chat-header .user-info {
        display: flex;
        align-items: center;
      }

      .chat-header img {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        margin-right: 1rem;
      }

      .chat-header h3 {
        font-size: 1.125rem;
        font-weight: 600;
        color: #1f2937;
      }

      .chat-header .online-status {
        font-size: 0.875rem;
        color: #22c55e;
      }

      .chat-header .actions {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .action-button {
        background: #4f46e5;
        color: #ffffff;
        border: none;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background 0.2s;
      }

      .action-button:hover {
        background: #4338ca;
      }

      .action-button.back-button {
        background: #6b7280;
        display: none;
      }

      .action-button.back-button:hover {
        background: #4b5563;
      }

      .search-bar {
        display: none;
        position: absolute;
        top: 1rem;
        left: 50%;
        transform: translateX(-50%);
        width: 50%;
        background: #ffffff;
        border: 1px solid #e5e7eb;
        border-radius: 9999px;
        padding: 0.5rem 1rem;
      }

      .search-bar.active {
        display: block;
      }

      .search-bar input {
        width: 100%;
        border: none;
        outline: none;
        font-size: 0.875rem;
      }

      .dropdown-menu {
        position: absolute;
        top: 3rem;
        right: 1rem;
        background: #ffffff;
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        z-index: 10;
        display: none;
      }

      .dropdown-menu.active {
        display: block;
      }

      .dropdown-menu button {
        display: block;
        width: 100%;
        padding: 0.5rem 1rem;
        background: none;
        border: none;
        text-align: left;
        font-size: 0.875rem;
        color: #1f2937;
        cursor: pointer;
      }

      .dropdown-menu button:hover {
        background: #f3f4f6;
      }

      .chat-body {
        flex: 1;
        min-height: 0;
        padding: 1.5rem;
        background: #f9fafb;
        background-image: url("/images/chat-background.png");
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        overflow-y: auto;
      }

      .date-header {
        text-align: center;
        margin: 1rem auto;
        font-size: 0.875rem;
        color: #6b7280;
        background: #ffffff;
        padding: 0.5rem;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        width: fit-content;
      }

      .message {
        margin-bottom: 1rem;
        display: flex;
        position: relative;
      }

      .message.sent {
        justify-content: flex-end;
      }

      .message.received {
        justify-content: flex-start;
      }

      .message-content {
        max-width: 300px;
        padding: 0.75rem;
        border-radius: 8px;
        position: relative;
      }

      .message.sent .message-content {
        background: #4f46e5;
        color: #ffffff;
      }

      .message.received .message-content {
        background: #e5e7eb;
        color: #1f2937;
      }

      .message-content p {
        margin: 0;
      }

      .message-content img {
        max-width: 100%;
        border-radius: 8px;
        cursor: pointer;
      }

      .message-content .audio-container {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        max-width: 100%;
      }

      .message-content .audio-container .play-pause-btn {
        background: #4f46e5;
        color: #ffffff;
        border: none;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
      }

      .message-content .audio-container .play-pause-btn:hover {
        background: #4338ca;
      }

      .message-content .audio-container .progress-bar {
        flex: 1;
        display: flex;
        gap: 1px;
        height: 40px;
        align-items: center;
      }

      .message-content .audio-container .progress-bar .bar {
        flex: 1;
        height: 20px;
        background: #f3f4f6;
        transition: background 0.2s;
      }

      .message-content .audio-container .progress-bar .bar.active {
        background: #4f46e5;
      }

      .message-content .audio-container .speed-btn {
        background: #6b7280;
        color: #ffffff;
        border: none;
        border-radius: 4px;
        padding: 0.25rem 0.5rem;
        font-size: 0.75rem;
        cursor: pointer;
      }

      .message-content .audio-container .speed-btn:hover {
        background: #4b5563;
      }

      .message-content .document-link {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        color: inherit;
        text-decoration: none;
      }

      .message-content .document-link i {
        font-size: 1rem;
      }

      .message-content .timestamp {
        font-size: 0.75rem;
        margin-top: 0.25rem;
        display: block;
      }

      .message.sent .timestamp {
        color: #e0e7ff;
      }

      .message.received .timestamp {
        color: #6b7280;
      }

      .read-receipt {
        position: absolute;
        bottom: 0.5rem;
        right: 0.5rem;
        display: flex;
        gap: 2px;
      }

      .read-receipt .dot {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background: #6b7280;
      }

      .read-receipt.read .dot {
        background: #4f46e5;
      }

      .message-input-container {
        padding: 1rem;
        background: #ffffff;
        border-top: 1px solid #e5e7eb;
        border-radius: 0 0 16px 0;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        position: relative;
      }

      .message-input-container .input-wrapper {
        display: flex;
        align-items: center;
        flex: 1;
      }

      .message-input {
        flex: 1;
        background: #f3f4f6;
        border-radius: 9999px;
        padding: 0.75rem 1.25rem;
        border: none;
        font-size: 1rem;
        outline: none;
      }

      .message-input:focus {
        box-shadow: 0 0 0 2px #818cf8;
      }

      .attach-button,
      .voice-button,
      .send-button,
      .call-button {
        background: #4f46e5;
        color: #ffffff;
        border: none;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background 0.2s;
      }

      .voice-button.recording {
        background: #ef4444;
      }

      .attach-button:hover,
      .voice-button:hover,
      .send-button:hover,
      .call-button:hover {
        background: #4338ca;
      }

      .voice-button.recording:hover {
        background: #dc2626;
      }

      .file-menu {
        position: absolute;
        bottom: 4.5rem;
        left: 1rem;
        background: #ffffff;
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        display: none;
        flex-direction: column;
        width: 150px;
        z-index: 10;
        animation: fadeIn 0.2s ease-in;
      }

      .file-menu.active {
        display: flex;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }

        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .file-menu button {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.75rem 1rem;
        background: none;
        border: none;
        font-size: 0.875rem;
        color: #1f2937;
        cursor: pointer;
      }

      .file-menu button:hover {
        background: #f3f4f6;
      }

      .file-menu button i {
        font-size: 1rem;
      }

      .camera-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }

      .camera-modal-content {
        background: #ffffff;
        padding: 1rem;
        border-radius: 8px;
        max-width: 400px;
        width: 90%;
        text-align: center;
      }

      .camera-modal-content video,
      .camera-modal-content img {
        width: 100%;
        max-height: 300px;
        border-radius: 8px;
        margin-bottom: 1rem;
      }

      .camera-modal-content .button-container {
        display: flex;
        gap: 0.5rem;
        justify-content: center;
      }

      .camera-modal-content button {
        background: #4f46e5;
        color: #ffffff;
        padding: 0.5rem 1rem;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.875rem;
      }

      .camera-modal-content button:hover {
        background: #4338ca;
      }

      .camera-modal-content button.cancel {
        background: #6b7280;
      }

      .camera-modal-content button.cancel:hover {
        background: #4b5563;
      }

      .call-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }

      .call-modal-content {
        background: #ffffff;
        padding: 2rem;
        border-radius: 8px;
        max-width: 400px;
        width: 90%;
        text-align: center;
      }

      .call-modal-content h2 {
        font-size: 1.5rem;
        color: #1f2937;
        margin-bottom: 1rem;
      }

      .call-modal-content .button-container {
        display: flex;
        gap: 1rem;
        justify-content: center;
      }

      .call-modal-content button {
        padding: 0.5rem 1rem;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.875rem;
      }

      .call-modal-content .accept-call {
        background: #22c55e;
        color: #ffffff;
      }

      .call-modal-content .accept-call:hover {
        background: #16a34a;
      }

      .call-modal-content .reject-call {
        background: #ef4444;
        color: #ffffff;
      }

      .call-modal-content .reject-call:hover {
        background: #dc2626;
      }

      .call-interface {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }

      .call-interface.active {
        display: flex;
      }

      .call-interface-content {
        background: #ffffff;
        padding: 2rem;
        border-radius: 8px;
        max-width: 400px;
        width: 90%;
        text-align: center;
      }

      .call-interface-content h2 {
        font-size: 1.5rem;
        color: #1f2937;
        margin-bottom: 0.5rem;
      }

      .call-interface-content .call-status {
        font-size: 1rem;
        color: #6b7280;
        margin-bottom: 1rem;
      }

      .call-interface-content .call-status.connected {
        color: #22c55e;
      }

      .call-interface-content .call-timer {
        font-size: 1rem;
        color: #1f2937;
        margin-bottom: 1rem;
      }

      .call-interface-content .button-container {
        display: flex;
        gap: 1rem;
        justify-content: center;
      }

      .call-interface-content button {
        padding: 0.5rem 1rem;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.875rem;
      }

      .call-interface-content .mute-button {
        background: #6b7280;
        color: #ffffff;
      }

      .call-interface-content .mute-button.muted {
        background: #eab308;
      }

      .call-interface-content .mute-button:hover {
        background: #4b5563;
      }

      .call-interface-content .mute-button.muted:hover {
        background: #ca8a04;
      }

      .call-interface-content .end-call-button {
        background: #ef4444;
        color: #ffffff;
      }

      .call-interface-content .end-call-button:hover {
        background: #dc2626;
      }

      .toast {
        position: fixed;
        top: 20px;
        right: 20px;
        background: #ef4444;
        color: #ffffff;
        padding: 1rem;
        border-radius: 5px;
        display: none;
        z-index: 1000;
      }

      .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }

      .modal-content {
        background: #ffffff;
        padding: 2rem;
        border-radius: 8px;
        max-width: 400px;
        width: 100%;
        text-align: center;
      }

      .modal-content img {
        width: 100px;
        height: 100px;
        border-radius: 50%;
        margin-bottom: 1rem;
      }

      .modal-content h2 {
        font-size: 1.5rem;
        color: #1f2937;
        margin-bottom: 0.5rem;
      }

      .modal-content p {
        font-size: 1rem;
        color: #6b7280;
        margin-bottom: 1rem;
      }

      .modal-content button {
        background: #4f46e5;
        color: #ffffff;
        padding: 0.5rem 1rem;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }

      .modal-content button:hover {
        background: #4338ca;
      }

      .image-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }

      .image-modal img {
        max-width: 90%;
        max-height: 90%;
        border-radius: 8px;
      }

      @media (max-width: 768px) {
        body {
          margin-left: 0;
        }

        .chat-container {
          flex-direction: column;
          height: 100vh;
          margin: 0;
        }

        .user-list-container {
          width: 100%;
          height: 100%;
          border-right: none;
          border-bottom: none;
          border-radius: 0;
          display: block;
        }

        .chat-window-container {
          width: 100%;
          height: 100%;
          display: none;
          position: absolute;
          top: 0;
          left: 0;
          background: #ffffff;
        }

        .chat-window-container.active {
          display: flex;
        }

        .action-button.back-button {
          display: flex;
        }

        .message-content .audio-container {
          max-width: 200px;
        }

        .file-menu {
          width: 120px;
          bottom: 4rem;
        }

        .camera-modal-content,
        .call-modal-content,
        .call-interface-content {
          width: 95%;
          max-width: 350px;
        }
      }

      @media (min-width: 769px) {
        .chat-window-container {
          display: flex;
        }

        .user-list-container {
          display: flex;
        }
      }
    </style>
  </head>

  <body>
    <%- include('../partials/sidebar') %>
    <main class="main-content" id="main-content">
      <div class="chat-container">
        <div class="user-list-container" id="userListContainer">
          <div class="user-list-header">
            <h2>Messages</h2>
          </div>
          <div class="search-container">
            <input
              type="text"
              id="searchUsersInput"
              class="search-input"
              placeholder="Search admins..."
            />
          </div>
          <div class="category-tabs">
            <div class="category-tab active" data-category="all">All</div>
            <div class="category-tab" data-category="unread">Unread</div>
          </div>
          <div class="user-list" id="userList"></div>
        </div>
        <div class="chat-window-container" id="chatWindowContainer">
          <div class="chat-header">
            <div class="user-info" id="chatHeaderUser">
              <button class="action-button back-button" id="backButton">
                <span class="material-icons">arrow_back</span>
              </button>
              <img
                src="https://www.gravatar.com/avatar/?d=retro"
                alt="Admin avatar"
                id="chatHeaderAvatar"
              />
              <div>
                <h3 id="chatHeaderName">Select an admin</h3>
                <p class="online-status">Online</p>
              </div>
            </div>
            <div class="actions">
              <button class="action-button call-button" id="callButton">
                <span class="material-icons">phone</span>
              </button>
              <button class="action-button" id="searchButton">
                <span class="material-icons">search</span>
              </button>
              <div class="search-bar" id="searchMessagesBar">
                <input
                  type="text"
                  id="searchMessagesInput"
                  placeholder="Search messages..."
                />
              </div>
              <button class="action-button" id="moreOptions">
                <span class="material-icons">more_vert</span>
              </button>
              <div class="dropdown-menu" id="dropdownMenu">
                <button id="clearChatsBtn">Clear Chats</button>
                <button id="viewProfileBtn">View Profile</button>
              </div>
            </div>
          </div>
          <div class="chat-body" id="chatWindow"></div>
          <div class="message-input-container">
            <button class="attach-button" id="attachButton">
              <span class="material-icons">attach_file</span>
            </button>
            <div class="file-menu" id="fileMenu">
              <button id="photoOption">
                <i class="fas fa-image" aria-hidden="true"></i> Photos
              </button>
              <button id="documentOption">
                <i class="fas fa-file" aria-hidden="true"></i> Documents
              </button>
              <button id="audioOption">
                <i class="fas fa-file-audio" aria-hidden="true"></i> Audio
              </button>
              <button id="cameraOption">
                <i class="fas fa-camera" aria-hidden="true"></i> Camera
              </button>
            </div>
            <input
              type="file"
              id="imageInput"
              accept="image/png,image/jpeg"
              style="display: none"
            />
            <input
              type="file"
              id="audioInput"
              accept="audio/mpeg,audio/wav,audio/webm"
              style="display: none"
            />
            <input
              type="file"
              id="documentInput"
              accept=".pdf,.doc,.docx"
              style="display: none"
            />
            <button class="voice-button" id="voiceButton">
              <span class="material-icons">mic</span>
            </button>
            <div class="input-wrapper">
              <input
                type="text"
                id="messageInput"
                class="message-input"
                placeholder="Type your message..."
              />
            </div>
            <button id="sendButton" class="send-button">
              <span class="material-icons">send</span>
            </button>
          </div>
        </div>
      </div>
      <div id="toast" class="toast"></div>
      <div id="profileModal" class="modal">
        <div class="modal-content">
          <img
            id="modalAvatar"
            src="https://www.gravatar.com/avatar/?d=retro"
            alt="Admin avatar"
          />
          <h2 id="modalName"></h2>
          <p id="modalEmail"></p>
          <p id="modalRole"></p>
          <button id="closeModal">Close</button>
        </div>
      </div>
      <div id="imageModal" class="image-modal">
        <img id="enlargedImage" src="" alt="Enlarged image" />
      </div>
      <div id="cameraModal" class="camera-modal">
        <div class="camera-modal-content">
          <video
            id="cameraStream"
            autoplay
            playsinline
            style="display: none"
          ></video>
          <img
            id="cameraPreview"
            style="display: none"
            alt="Captured photo preview"
          />
          <canvas id="cameraCanvas" style="display: none"></canvas>
          <div class="button-container">
            <button id="capturePhoto">Capture</button>
            <button id="sendPhoto" style="display: none">Send</button>
            <button id="cancelCamera" class="cancel">Cancel</button>
          </div>
        </div>
      </div>
      <div id="callModal" class="call-modal">
        <div class="call-modal-content">
          <h2 id="callerName">Incoming Call</h2>
          <div class="button-container">
            <button id="acceptCall" class="accept-call">Accept</button>
            <button id="rejectCall" class="reject-call">Reject</button>
          </div>
        </div>
      </div>
      <div id="callInterface" class="call-interface">
        <div class="call-interface-content">
          <h2 id="callInterfaceName">Call</h2>
          <p id="callStatus" class="call-status">Connecting...</p>
          <p id="callTimer" class="call-timer">00:00:00</p>
          <div class="button-container">
            <button id="muteButton" class="mute-button">Mute</button>
            <button id="endCallButton" class="end-call-button">End Call</button>
          </div>
        </div>
      </div>
    </main>
    <script src="https://cdn.ably.io/lib/ably.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.4.0/purify.min.js"></script>
    <script src="/js/sidebar.js"></script>
    <script>
document.addEventListener("DOMContentLoaded", async () => {
  const user = JSON.parse(localStorage.getItem("user") || "{}");
  const token = localStorage.getItem("token");
  const userId = "<%= user._id || '' %>";
  const userName = "<%= user.name || '' %>";
  if (!user.name || !user.email || !token || !userId || !userName) {
    showToast("Please log in to access this page.");
    setTimeout(() => {
      window.location.href = "/signup?redirect=" + encodeURIComponent(window.location.pathname);
    }, 1000);
    return;
  }

  const sidebar = document.querySelector(".sidebar");
  const mainContent = document.querySelector(".main-content");
  if (sidebar && mainContent) {
    if (sidebar.classList.contains("hidden")) {
      mainContent.classList.add("full");
    }
    sidebar.addEventListener("transitionend", () => {
      mainContent.classList.toggle("full", sidebar.classList.contains("hidden"));
    });
  }

  // Initialize Ably
  const ably = new Ably.Realtime({
    authUrl: "/api/messaging/ably-auth",
    authHeaders: {
      Authorization: `Bearer ${token}`,
    },
    clientId: userId,
    echoMessages: false,
  });

  ably.connection.on("connected", () => {
    console.log("Ably connected successfully");
  });
  ably.connection.on("failed", (err) => {
    console.error("Ably connection failed:", err);
    showToast("Failed to connect to real-time service: " + err.message);
  });

  // DOM Elements
  const userList = document.getElementById("userList");
  const chatWindow = document.getElementById("chatWindow");
  const messageInput = document.getElementById("messageInput");
  const sendButton = document.getElementById("sendButton");
  const attachButton = document.getElementById("attachButton");
  const fileMenu = document.getElementById("fileMenu");
  const photoOption = document.getElementById("photoOption");
  const documentOption = document.getElementById("documentOption");
  const audioOption = document.getElementById("audioOption");
  const cameraOption = document.getElementById("cameraOption");
  const imageInput = document.getElementById("imageInput");
  const audioInput = document.getElementById("audioInput");
  const documentInput = document.getElementById("documentInput");
  const voiceButton = document.getElementById("voiceButton");
  const chatHeaderName = document.getElementById("chatHeaderName");
  const chatHeaderAvatar = document.getElementById("chatHeaderAvatar");
  const moreOptions = document.getElementById("moreOptions");
  const dropdownMenu = document.getElementById("dropdownMenu");
  const clearChatsBtn = document.getElementById("clearChatsBtn");
  const viewProfileBtn = document.getElementById("viewProfileBtn");
  const profileModal = document.getElementById("profileModal");
  const modalAvatar = document.getElementById("modalAvatar");
  const modalName = document.getElementById("modalName");
  const modalEmail = document.getElementById("modalEmail");
  const modalRole = document.getElementById("modalRole");
  const closeModal = document.getElementById("closeModal");
  const imageModal = document.getElementById("imageModal");
  const enlargedImage = document.getElementById("enlargedImage");
  const userListContainer = document.getElementById("userListContainer");
  const chatWindowContainer = document.getElementById("chatWindowContainer");
  const backButton = document.getElementById("backButton");
  const searchButton = document.getElementById("searchButton");
  const searchMessagesBar = document.getElementById("searchMessagesBar");
  const searchMessagesInput = document.getElementById("searchMessagesInput");
  const searchUsersInput = document.getElementById("searchUsersInput");
  const cameraModal = document.getElementById("cameraModal");
  const cameraStream = document.getElementById("cameraStream");
  const cameraPreview = document.getElementById("cameraPreview");
  const cameraCanvas = document.getElementById("cameraCanvas");
  const capturePhoto = document.getElementById("capturePhoto");
  const sendPhoto = document.getElementById("sendPhoto");
  const cancelCamera = document.getElementById("cancelCamera");
  const callButton = document.getElementById("callButton");
  const callModal = document.getElementById("callModal");
  const callerName = document.getElementById("callerName");
  const acceptCall = document.getElementById("acceptCall");
  const rejectCall = document.getElementById("rejectCall");
  const callInterface = document.getElementById("callInterface");
  const callInterfaceName = document.getElementById("callInterfaceName");
  const callStatus = document.getElementById("callStatus");
  const callTimer = document.getElementById("callTimer");
  const muteButton = document.getElementById("muteButton");
  const endCallButton = document.getElementById("endCallButton");
  const categoryTabs = document.querySelectorAll(".category-tab");

  // State Variables
  let selectedUserId = localStorage.getItem("selectedUserId") || null;
  let currentCategory = "all";
  let mediaRecorder = null;
  let audioChunks = [];
  let sentMessageIds = new Set();
  let isSending = false;
  let currentMessages = [];
  let audioElements = new Map();
  let peerConnection = null;
  let localStream = null;
  let remoteStream = null;
  let isMuted = false;
  let callStartTime = null;
  let callTimerInterval = null;
  const speedOptions = [1, 1.2, 1.5, 2];
  const webrtcConfig = {
    iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
  };

  // Ably Channels
  const userChannel = ably.channels.get(`users-${userId}`);
  const messageChannel = ably.channels.get(`messages-${userId}`);
  const callChannel = ably.channels.get(`calls-${userId}`);

  function showToast(message) {
    const toast = document.getElementById("toast");
    if (toast) {
      toast.textContent = message;
      toast.style.display = "block";
      setTimeout(() => {
        toast.style.display = "none";
      }, 3000);
    }
  }

  function formatMessageTime(timestamp) {
    const now = new Date();
    const messageDate = new Date(timestamp);
    const diffDays = Math.floor((now - messageDate) / (1000 * 60 * 60 * 24));
    const isSameWeek =
      Math.floor((now.getDay() + 6) / 7) ===
      Math.floor((messageDate.getDay() + 6) / 7);

    if (diffDays === 0) {
      return messageDate.toLocaleTimeString([], {
        hour: "2-digit",
        minute: "2-digit",
      });
    } else if (diffDays === 1) {
      return "Yesterday";
    } else if (isSameWeek) {
      return messageDate.toLocaleString("en-US", { weekday: "long" });
    } else {
      return messageDate.toLocaleDateString();
    }
  }

  function formatCallTime(seconds) {
    const hrs = Math.floor(seconds / 3600);
    const mins = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    return `${hrs.toString().padStart(2, "0")}:${mins
      .toString()
      .padStart(2, "0")}:${secs.toString().padStart(2, "0")}`;
  }

  function startCallTimer() {
    callStartTime = Date.now();
    callTimerInterval = setInterval(() => {
      if (callTimer) {
        const seconds = Math.floor((Date.now() - callStartTime) / 1000);
        callTimer.textContent = formatCallTime(seconds);
      }
    }, 1000);
  }

  function stopCallTimer() {
    if (callTimerInterval) {
      clearInterval(callTimerInterval);
      callTimerInterval = null;
    }
    if (callTimer) {
      callTimer.textContent = "00:00:00";
    }
  }

  function debounce(func, wait) {
    let timeout;
    return function (...args) {
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(this, args), wait);
    };
  }

  function appendMessage(
    isSent,
    senderName,
    content,
    timestamp,
    messageId,
    messageType,
    isRead,
    fileMetadata,
    status = "pending"
  ) {
    if (document.getElementById(`message-${messageId}`)) {
      console.log("Message already exists, skipping:", messageId);
      return;
    }
    const messageDate = new Date(timestamp);
    const lastDate = chatWindow.dataset.lastDate
      ? new Date(chatWindow.dataset.lastDate)
      : null;
    const dateString = messageDate.toDateString();
    if (!lastDate || lastDate.toDateString() !== dateString) {
      const dateHeader = document.createElement("div");
      dateHeader.className = "date-header";
      dateHeader.textContent = formatMessageTime(timestamp);
      chatWindow.appendChild(dateHeader);
      chatWindow.dataset.lastDate = messageDate;
    }

    const messageDiv = document.createElement("div");
    messageDiv.className = `message ${isSent ? "sent" : "received"} ${
      status === "pending" ? "pending" : ""
    }`;
    messageDiv.id = `message-${messageId}`;
    let contentHtml;
    if (
      messageType === "image" ||
      (content.startsWith("https://res.cloudinary.com/") &&
        (content.endsWith(".jpg") ||
          content.endsWith(".png") ||
          content.endsWith(".jpeg")))
    ) {
      contentHtml = `<img src="${DOMPurify.sanitize(
        content
      )}" alt="Image message" />`;
    } else if (
      messageType === "audio" ||
      (content.startsWith("https://res.cloudinary.com/") &&
        (content.endsWith(".mp3") ||
          content.endsWith(".wav") ||
          content.endsWith(".webm")))
    ) {
      contentHtml = `
        <div class="audio-container" data-message-id="${messageId}">
          <button class="play-pause-btn" data-message-id="${messageId}">
            <i class="fas fa-play" aria-hidden="true"></i>
          </button>
          <div class="progress-bar" id="progress-bar-${messageId}">
            ${Array(20)
              .fill()
              .map((_, i) => `<div class="bar" data-index="${i}"></div>`)
              .join("")}
          </div>
          <button class="speed-btn" data-message-id="${messageId}" data-speed-index="0">1x</button>
        </div>
      `;
    } else if (
      messageType === "document" ||
      (content.startsWith("https://res.cloudinary.com/") &&
        (content.endsWith(".pdf") ||
          content.endsWith(".doc") ||
          content.endsWith(".docx")))
    ) {
      contentHtml = `
        <a href="${DOMPurify.sanitize(
          content
        )}" target="_blank" class="document-link">
          <i class="fas fa-file" aria-hidden="true"></i> ${DOMPurify.sanitize(
            fileMetadata?.fileName || "Document"
          )}
        </a>
      `;
    } else {
      contentHtml = `<p>${DOMPurify.sanitize(content)}</p>`;
    }
    messageDiv.innerHTML = `
      <div class="message-content">
        ${contentHtml}
        <span class="timestamp">${formatMessageTime(timestamp)}</span>
        ${
          isSent
            ? `<div class="read-receipt ${
                status === "delivered" ? (isRead ? "read" : "") : status
              }"><span class="dot"></span><span class="dot"></span></div>`
            : ""
        }
      </div>
    `;
    chatWindow.appendChild(messageDiv);
    chatWindow.scrollTop = chatWindow.scrollHeight;

    if (
      messageType === "audio" ||
      (content.startsWith("https://res.cloudinary.com/") &&
        (content.endsWith(".mp3") ||
          content.endsWith(".wav") ||
          content.endsWith(".webm")))
    ) {
      const audio = new Audio(DOMPurify.sanitize(content));
      audioElements.set(messageId, audio);

      const playPauseBtn = messageDiv.querySelector(
        `.play-pause-btn[data-message-id="${messageId}"]`
      );
      const progressBar = messageDiv.querySelector(`#progress-bar-${messageId}`);
      const bars = progressBar.querySelectorAll(".bar");
      playPauseBtn.addEventListener("click", () => {
        if (audio.paused) {
          audio.play();
          messageDiv.querySelector(".audio-container").classList.add("playing");
          playPauseBtn
            .querySelector("i")
            .classList.replace("fa-play", "fa-pause");
          updateProgressBar(audio, bars, messageId);
        } else {
          audio.pause();
          messageDiv
            .querySelector(".audio-container")
            .classList.remove("playing");
          playPauseBtn
            .querySelector("i")
            .classList.replace("fa-pause", "fa-play");
          bars.forEach((bar) => bar.classList.remove("active"));
        }
      });

      audio.addEventListener("ended", () => {
        messageDiv.querySelector(".audio-container").classList.remove("playing");
        playPauseBtn
          .querySelector("i")
          .classList.replace("fa-pause", "fa-play");
        bars.forEach((bar) => bar.classList.remove("active"));
      });

      const speedBtn = messageDiv.querySelector(
        `.speed-btn[data-message-id="${messageId}"]`
      );
      speedBtn.addEventListener("click", () => {
        let currentIndex = parseInt(speedBtn.dataset.speedIndex);
        currentIndex = (currentIndex + 1) % speedOptions.length;
        const newSpeed = speedOptions[currentIndex];
        audio.playbackRate = newSpeed;
        speedBtn.dataset.speedIndex = currentIndex;
        speedBtn.textContent = `${newSpeed}x`;
      });
    }
  }

  function updateProgressBar(audio, bars, messageId) {
    const update = () => {
      if (!audio.paused && !audio.ended) {
        const progress = audio.currentTime / audio.duration;
        const activeBars = Math.floor(progress * bars.length);
        bars.forEach((bar, index) => {
          bar.classList.toggle("active", index < activeBars);
        });
        requestAnimationFrame(update);
      }
    };
    update();
  }

  function updateMessageStatus(messageId, status, isRead = false) {
    const messageElement = document.getElementById(`message-${messageId}`);
    if (messageElement) {
      const readReceipt = messageElement.querySelector(".read-receipt");
      if (readReceipt) {
        readReceipt.className = `read-receipt ${
          status === "delivered" ? (isRead ? "read" : "") : status
        }`;
      }
      if (status === "delivered") {
        messageElement.classList.remove("pending");
      }
    }
  }

  function displayMessages(messages) {
    chatWindow.innerHTML = "";
    chatWindow.dataset.lastDate = null;
    audioElements.forEach((audio) => audio.pause());
    audioElements.clear();
    messages.forEach((msg) => {
      appendMessage(
        msg.sender._id === userId,
        msg.sender.name,
        msg.content,
        msg.createdAt,
        msg._id,
        msg.messageType || "text",
        msg.isRead,
        msg.fileMetadata,
        "delivered"
      );
    });
  }

  function closeCallModal() {
    if (callModal) {
      callModal.style.display = "none";
      callerName.textContent = "Incoming Call";
      callModal.dataset.callerId = "";
      callModal.dataset.offer = "";
    }
  }

  function endCall() {
    if (peerConnection) {
      peerConnection.close();
      peerConnection = null;
    }
    if (localStream) {
      localStream.getTracks().forEach((track) => track.stop());
      localStream = null;
    }
    if (remoteStream) {
      remoteStream.getTracks().forEach((track) => track.stop());
      remoteStream = null;
    }
    if (callInterface) {
      callInterface.classList.remove("active");
    }
    if (muteButton) {
      muteButton.textContent = "Mute";
      muteButton.classList.remove("muted");
    }
    isMuted = false;
    stopCallTimer();
    if (selectedUserId) {
      callChannel.publish("endCall", { to: selectedUserId }, (err) => {
        if (err) {
          showToast("Failed to end call: " + err.message);
        }
      });
    }
  }

  async function sendMessage(content, messageType = "text", fileMetadata = {}, retryCount = 0) {
    if (!selectedUserId || !content) {
      showToast("Please select a user and enter a message or select a file.");
      return;
    }
    if (isSending) {
      return;
    }
    isSending = true;

    const tempMessageId = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    sentMessageIds.add(tempMessageId);

    appendMessage(
      true,
      userName,
      content,
      new Date(),
      tempMessageId,
      messageType,
      false,
      fileMetadata,
      "pending"
    );

    try {
      const userResponse = await fetch("/api/users", {
        headers: { Authorization: `Bearer ${token}` },
      });
      const userData = await userResponse.json();
      if (userData.status === "success") {
        const selectedUser = userData.users.find((u) => u._id === selectedUserId);
        if (selectedUser) {
          if (messageType === "image" || messageType === "audio" || messageType === "document") {
            const base64Size = (content.length * 3) / 4 / 1024 / 1024;
            if (base64Size > 5) {
              showToast(`${messageType} size exceeds 5MB after encoding.`);
              sentMessageIds.delete(tempMessageId);
              isSending = false;
              const tempMessage = document.getElementById(`message-${tempMessageId}`);
              if (tempMessage) tempMessage.remove();
              return;
            }
          }

          messageChannel.publish(
            "sendMessage",
            {
              receiverId: selectedUserId,
              content,
              messageType,
              fileName: fileMetadata.fileName || "file",
              fileSize: fileMetadata.fileSize || 0,
              fileType: fileMetadata.fileType || "",
              tempMessageId,
            },
            async (err) => {
              isSending = false;
              if (!err) {
                messageInput.value = "";
                imageInput.value = "";
                audioInput.value = "";
                documentInput.value = "";
                sentMessageIds.delete(tempMessageId);
                const response = await fetch(`/api/messages?userId=${selectedUserId}`, {
                  headers: { Authorization: `Bearer ${token}` },
                });
                const msgData = await response.json();
                if (msgData.status === "success") {
                  currentMessages = msgData.messages;
                  displayMessages(currentMessages);
                } else {
                  showToast("Failed to refresh messages: " + msgData.message);
                }
              } else {
                showToast(`Failed to send ${messageType}: ${err.message}`);
                updateMessageStatus(tempMessageId, "failed");
                if (retryCount < 2 && (messageType === "image" || messageType === "audio" || messageType === "document")) {
                  setTimeout(() => sendMessage(content, messageType, fileMetadata, retryCount + 1), 2000);
                } else {
                  showToast(`Failed to send ${messageType} after ${retryCount + 1} attempts.`);
                }
              }
            }
          );
        } else {
          showToast("Selected user not found.");
          sentMessageIds.delete(tempMessageId);
          isSending = false;
          updateMessageStatus(tempMessageId, "failed");
        }
      } else {
        showToast("Failed to verify user: " + userData.message);
        sentMessageIds.delete(tempMessageId);
        isSending = false;
        updateMessageStatus(tempMessageId, "failed");
      }
    } catch (err) {
      showToast("Error sending message: " + err.message);
      sentMessageIds.delete(tempMessageId);
      isSending = false;
      updateMessageStatus(tempMessageId, "failed");
    }
  }

  async function updateUserList(users) {
    if (!userList) return;
    userList.innerHTML = "";
    users.forEach((user) => {
      if (user._id !== userId) {
        const userItem = document.createElement("div");
        userItem.className = `user-item ${selectedUserId === user._id ? "selected" : ""}`;
        userItem.dataset.userId = user._id;
        userItem.innerHTML = `
          <img src="${DOMPurify.sanitize(user.profileImage)}" alt="${DOMPurify.sanitize(user.name)}'s avatar" />
          <div class="user-info">
            <h3>${DOMPurify.sanitize(user.name)}</h3>
            <p>${DOMPurify.sanitize(user.lastMessage || "")}</p>
          </div>
          <span class="message-time">${user.lastMessageTime ? formatMessageTime(user.lastMessageTime) : ""}</span>
          ${user.unreadCount > 0 ? `<span class="unread-count">${user.unreadCount}</span>` : ""}
          <button class="favorite-btn ${user.isFavorite ? "favorite" : ""}">
            <i class="fas fa-star"></i>
          </button>
          <button class="call-btn">Call</button>
        `;
        userList.appendChild(userItem);

        userItem.addEventListener("click", async (e) => {
          if (e.target.closest(".favorite-btn") || e.target.closest(".call-btn")) return;
          document.querySelectorAll(".user-item").forEach((item) => item.classList.remove("selected"));
          userItem.classList.add("selected");
          selectedUserId = user._id;
          localStorage.setItem("selectedUserId", selectedUserId);
          chatHeaderName.textContent = DOMPurify.sanitize(user.name);
          chatHeaderAvatar.src = DOMPurify.sanitize(user.profileImage);
          chatWindowContainer.classList.add("active");
          userListContainer.style.display = "none";
          searchMessagesInput.value = "";
          searchMessagesBar.classList.remove("active");
          try {
            const response = await fetch(`/api/messages?userId=${selectedUserId}`, {
              headers: { Authorization: `Bearer ${token}` },
            });
            const data = await response.json();
            if (data.status === "success") {
              currentMessages = data.messages;
              displayMessages(currentMessages);
            } else {
              showToast("Failed to fetch messages: " + data.message);
            }
          } catch (err) {
            showToast("Error fetching messages: " + err.message);
          }
        });

        const favoriteBtn = userItem.querySelector(".favorite-btn");
        favoriteBtn.addEventListener("click", async () => {
          favoriteBtn.classList.toggle("favorite");
          const isFavorite = favoriteBtn.classList.contains("favorite");
          try {
            const response = await fetch(`/api/users/${user._id}/favorite`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${token}`,
              },
              body: JSON.stringify({ isFavorite }),
            });
            const data = await response.json();
            if (data.status !== "success") {
              showToast("Failed to update favorite status: " + data.message);
              favoriteBtn.classList.toggle("favorite");
            }
          } catch (err) {
            showToast("Failed to update favorite status: " + err.message);
            favoriteBtn.classList.toggle("favorite");
          }
        });

        const callBtn = userItem.querySelector(".call-btn");
        callBtn.addEventListener("click", () => {
          selectedUserId = user._id;
          callButton.click();
        });
      }
    });
  }

  // Event Listeners
  if (sendButton) {
    sendButton.addEventListener("click", debounce(() => sendMessage(messageInput.value.trim()), 300));
  }

  if (messageInput) {
    messageInput.addEventListener("keypress", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        sendMessage(messageInput.value.trim());
      }
    });
  }

  if (attachButton) {
    attachButton.addEventListener("click", () => {
      fileMenu.classList.toggle("active");
    });
  }

  document.addEventListener("click", (e) => {
    if (fileMenu && !fileMenu.contains(e.target) && !attachButton.contains(e.target)) {
      fileMenu.classList.remove("active");
    }
    if (cameraModal && !cameraModal.contains(e.target) && !cameraOption.contains(e.target) && cameraModal.style.display === "flex") {
      closeCameraModal();
    }
    if (dropdownMenu && !dropdownMenu.contains(e.target) && !moreOptions.contains(e.target)) {
      dropdownMenu.classList.remove("active");
    }
  });

  if (photoOption) {
    photoOption.addEventListener("click", () => {
      fileMenu.classList.remove("active");
      imageInput.click();
    });
  }

  if (documentOption) {
    documentOption.addEventListener("click", () => {
      fileMenu.classList.remove("active");
      documentInput.click();
    });
  }

  if (audioOption) {
    audioOption.addEventListener("click", () => {
      fileMenu.classList.remove("active");
      audioInput.click();
    });
  }

  let cameraStreamObj = null;
  function closeCameraModal() {
    if (cameraStreamObj) {
      cameraStreamObj.getTracks().forEach((track) => track.stop());
      cameraStreamObj = null;
    }
    if (cameraStream) cameraStream.style.display = "none";
    if (cameraPreview) cameraPreview.style.display = "none";
    if (cameraPreview) cameraPreview.src = "";
    if (capturePhoto) capturePhoto.style.display = "block";
    if (sendPhoto) sendPhoto.style.display = "none";
    if (cancelCamera) cancelCamera.style.display = "block";
    if (cameraModal) cameraModal.style.display = "none";
  }

  if (cameraOption) {
    cameraOption.addEventListener("click", () => {
      fileMenu.classList.remove("active");
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        showToast("Camera is not supported in this browser.");
        return;
      }
      navigator.mediaDevices
        .getUserMedia({
          video: {
            facingMode: { ideal: "environment" },
            width: { ideal: 1280 },
            height: { ideal: 720 },
          },
        })
        .then((stream) => {
          cameraStreamObj = stream;
          if (cameraStream) {
            cameraStream.srcObject = stream;
            cameraStream.style.display = "block";
          }
          if (cameraPreview) cameraPreview.style.display = "none";
          if (capturePhoto) capturePhoto.style.display = "block";
          if (sendPhoto) sendPhoto.style.display = "none";
          if (cancelCamera) cancelCamera.style.display = "block";
          if (cameraModal) cameraModal.style.display = "flex";
        })
        .catch((err) => {
          showToast("Failed to access camera: " + err.message);
        });
    });
  }

  if (capturePhoto) {
    capturePhoto.addEventListener("click", () => {
      if (cameraCanvas && cameraStream) {
        const context = cameraCanvas.getContext("2d");
        cameraCanvas.width = cameraStream.videoWidth;
        cameraCanvas.height = cameraStream.videoHeight;
        context.drawImage(cameraStream, 0, 0, cameraCanvas.width, cameraCanvas.height);
        if (cameraPreview) {
          cameraPreview.src = cameraCanvas.toDataURL("image/jpeg", 0.8);
          cameraStream.style.display = "none";
          cameraPreview.style.display = "block";
          capturePhoto.style.display = "none";
          sendPhoto.style.display = "block";
          cancelCamera.style.display = "block";
        }
      }
    });
  }

  if (sendPhoto) {
    sendPhoto.addEventListener("click", () => {
      if (cameraPreview) {
        const base64 = cameraPreview.src;
        const fileSize = (base64.length * 3) / 4;
        sendMessage(base64, "image", {
          fileName: `photo_${Date.now()}.jpg`,
          fileSize: fileSize,
          fileType: "image/jpeg",
        });
        closeCameraModal();
      }
    });
  }

  if (cancelCamera) {
    cancelCamera.addEventListener("click", closeCameraModal);
  }

  if (imageInput) {
    imageInput.addEventListener("change", () => {
      const file = imageInput.files[0];
      if (file) {
        if (!["image/png", "image/jpeg"].includes(file.type)) {
          showToast("Only PNG and JPEG images are allowed.");
          return;
        }
        if (file.size > 5 * 1024 * 1024) {
          showToast("Image size must be less than 5MB.");
          return;
        }
        const reader = new FileReader();
        reader.onload = () => {
          const base64 = reader.result;
          sendMessage(base64, "image", {
            fileName: file.name,
            fileSize: file.size,
            fileType: file.type,
          });
        };
        reader.onerror = () => {
          showToast("Failed to read image file.");
        };
        reader.readAsDataURL(file);
      }
    });
  }

  if (audioInput) {
    audioInput.addEventListener("change", () => {
      const file = audioInput.files[0];
      if (file) {
        if (!["audio/mpeg", "audio/wav", "audio/webm"].includes(file.type)) {
          showToast("Only MP3, WAV, and WebM audio files are allowed.");
          return;
        }
        if (file.size > 5 * 1024 * 1024) {
          showToast("Audio size must be less than 5MB.");
          return;
        }
        const reader = new FileReader();
        reader.onload = () => {
          const base64 = reader.result;
          sendMessage(base64, "audio", {
            fileName: file.name,
            fileSize: file.size,
            fileType: file.type,
          });
        };
        reader.onerror = () => {
          showToast("Failed to read audio file.");
        };
        reader.readAsDataURL(file);
      }
    });
  }

  if (documentInput) {
    documentInput.addEventListener("change", () => {
      const file = documentInput.files[0];
      if (file) {
        if (
          ![
            "application/pdf",
            "application/msword",
            "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
          ].includes(file.type)
        ) {
          showToast("Only PDF, DOC, and DOCX files are allowed.");
          return;
        }
        if (file.size > 5 * 1024 * 1024) {
          showToast("Document size must be less than 5MB.");
          return;
        }
        const reader = new FileReader();
        reader.onload = () => {
          const base64 = reader.result;
          sendMessage(base64, "document", {
            fileName: file.name,
            fileSize: file.size,
            fileType: file.type,
          });
        };
        reader.onerror = () => {
          showToast("Failed to read document file.");
        };
        reader.readAsDataURL(file);
      }
    });
  }

  if (voiceButton) {
    voiceButton.addEventListener("mousedown", () => {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        showToast("Voice recording is not supported in this browser.");
        return;
      }
      navigator.mediaDevices
        .getUserMedia({ audio: true })
        .then((stream) => {
          mediaRecorder = new MediaRecorder(stream, { mimeType: "audio/webm;codecs=opus" });
          audioChunks = [];
          mediaRecorder.start();
          voiceButton.classList.add("recording");
          mediaRecorder.ondataavailable = (e) => {
            if (e.data.size > 0) {
              audioChunks.push(e.data);
            }
          };
          mediaRecorder.onstop = () => {
            const audioBlob = new Blob(audioChunks, { type: "audio/webm" });
            if (audioBlob.size > 5 * 1024 * 1024) {
              showToast("Voice message size must be less than 5MB.");
              stream.getTracks().forEach((track) => track.stop());
              voiceButton.classList.remove("recording");
              return;
            }
            const reader = new FileReader();
            reader.onload = () => {
              const base64 = reader.result;
              sendMessage(base64, "audio", {
                fileName: `voice_${Date.now()}.webm`,
                fileSize: audioBlob.size,
                fileType: "audio/webm",
              });
            };
            reader.onerror = () => {
              showToast("Failed to process voice message.");
            };
            reader.readAsDataURL(audioBlob);
            stream.getTracks().forEach((track) => track.stop());
            voiceButton.classList.remove("recording");
          };
          mediaRecorder.onerror = (e) => {
            showToast("Error recording audio: " + e.error);
            stream.getTracks().forEach((track) => track.stop());
            voiceButton.classList.remove("recording");
          };
        })
        .catch((err) => {
          showToast("Failed to access microphone: " + err.message);
        });
    });

    voiceButton.addEventListener("mouseup", () => {
      if (mediaRecorder && mediaRecorder.state === "recording") {
        mediaRecorder.stop();
      }
    });

    voiceButton.addEventListener("mouseleave", () => {
      if (mediaRecorder && mediaRecorder.state === "recording") {
        mediaRecorder.stop();
      }
    });
  }

  if (moreOptions) {
    moreOptions.addEventListener("click", () => {
      dropdownMenu.classList.toggle("active");
    });
  }

  if (clearChatsBtn) {
    clearChatsBtn.addEventListener("click", () => {
      if (selectedUserId) {
        if (confirm("Are you sure you want to clear chats with this user?")) {
          messageChannel.publish("clearChats", { userId: selectedUserId }, async (err) => {
            if (!err) {
              showToast("Chats cleared successfully");
              chatWindow.innerHTML = "";
              chatWindow.dataset.lastDate = null;
            } else {
              showToast("Failed to clear chats: " + err.message);
            }
          });
        }
      } else {
        showToast("Please select a user.");
      }
    });
  }

  if (viewProfileBtn) {
    viewProfileBtn.addEventListener("click", async () => {
      if (selectedUserId) {
        try {
          const response = await fetch(`/api/users/${selectedUserId}`, {
            headers: { Authorization: `Bearer ${token}` },
          });
          const data = await response.json();
          if (data.status === "success") {
            modalAvatar.src = DOMPurify.sanitize(data.user.profileImage);
            modalName.textContent = DOMPurify.sanitize(data.user.name);
            modalEmail.textContent = DOMPurify.sanitize(data.user.email);
            modalRole.textContent = DOMPurify.sanitize(
              data.user.role.charAt(0).toUpperCase() + data.user.role.slice(1)
            );
            profileModal.style.display = "flex";
          } else {
            showToast("Failed to fetch profile: " + data.message);
          }
        } catch (err) {
          showToast("Failed to fetch profile: " + err.message);
        }
      } else {
        showToast("Please select a user.");
      }
    });
  }

  if (closeModal) {
    closeModal.addEventListener("click", () => {
      profileModal.style.display = "none";
    });
  }

  if (imageModal) {
    imageModal.addEventListener("click", () => {
      imageModal.style.display = "none";
    });
  }

  if (chatWindow) {
    chatWindow.addEventListener("click", (e) => {
      if (e.target.tagName === "IMG" && !e.target.closest(".audio-container")) {
        enlargedImage.src = DOMPurify.sanitize(e.target.src);
        imageModal.style.display = "flex";
      }
    });
  }

  if (backButton) {
    backButton.addEventListener("click", () => {
      chatWindowContainer.classList.remove("active");
      userListContainer.style.display = "block";
      searchMessagesBar.classList.remove("active");
    });
  }

  if (searchButton) {
    searchButton.addEventListener("click", () => {
      searchMessagesBar.classList.toggle("active");
      if (searchMessagesBar.classList.contains("active")) {
        searchMessagesInput.focus();
      } else {
        searchMessagesInput.value = "";
        displayMessages(currentMessages);
      }
    });
  }

  if (searchMessagesInput) {
    searchMessagesInput.addEventListener("input", debounce(() => {
      const query = searchMessagesInput.value.trim().toLowerCase();
      if (query) {
        const filteredMessages = currentMessages.filter(
          (msg) =>
            msg.content.toLowerCase().includes(query) ||
            msg.sender.name.toLowerCase().includes(query)
        );
        displayMessages(filteredMessages);
      } else {
        displayMessages(currentMessages);
      }
    }, 300));
  }

  if (searchUsersInput) {
    searchUsersInput.addEventListener("input", debounce(async () => {
      try {
        const response = await fetch("/api/users", {
          headers: { Authorization: `Bearer ${token}` },
        });
        const data = await response.json();
        if (data.status === "success") {
          const query = searchUsersInput.value.trim().toLowerCase();
          let filteredUsers = data.users.filter((user) => user.role === "admin");
          if (query) {
            filteredUsers = filteredUsers.filter(
              (user) =>
                user.name.toLowerCase().includes(query) ||
                user.email.toLowerCase().includes(query)
            );
          }
          if (currentCategory === "unread") {
            filteredUsers = filteredUsers.filter((u) => u.unreadCount > 0);
          }
          updateUserList(filteredUsers);
        } else {
          showToast("Failed to fetch users: " + data.message);
        }
      } catch (err) {
        showToast("Error fetching users: " + err.message);
      }
    }, 300));
  }

  if (categoryTabs) {
    categoryTabs.forEach((tab) => {
      tab.addEventListener("click", async () => {
        categoryTabs.forEach((t) => t.classList.remove("active"));
        tab.classList.add("active");
        currentCategory = tab.dataset.category;
        try {
          const response = await fetch("/api/users", {
            headers: { Authorization: `Bearer ${token}` },
          });
          const data = await response.json();
          if (data.status === "success") {
            let filteredUsers = data.users.filter((user) => user.role === "admin");
            if (currentCategory === "unread") {
              filteredUsers = filteredUsers.filter((u) => u.unreadCount > 0);
            }
            updateUserList(filteredUsers);
          } else {
            showToast("Failed to fetch users: " + data.message);
          }
        } catch (err) {
          showToast("Error fetching users: " + err.message);
        }
      });
    });
  }

  if (callButton) {
    callButton.addEventListener("click", async () => {
      if (!selectedUserId) {
        showToast("Please select a user to call.");
        return;
      }
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        peerConnection = new RTCPeerConnection(webrtcConfig);
        localStream.getTracks().forEach((track) => peerConnection.addTrack(track, localStream));

        peerConnection.ontrack = (event) => {
          remoteStream = event.streams[0];
          const audio = document.createElement("audio");
          audio.srcObject = remoteStream;
          audio.autoplay = true;
          document.body.appendChild(audio);
        };

        peerConnection.onicecandidate = (event) => {
          if (event.candidate) {
            callChannel.publish("iceCandidate", { to: selectedUserId, candidate: event.candidate }, (err) => {
              if (err) {
                showToast("Failed to send ICE candidate: " + err.message);
              }
            });
          }
        };

        peerConnection.onconnectionstatechange = () => {
          if (peerConnection.connectionState === "connected" && callInterface && callStatus) {
            callStatus.textContent = "Connected";
            callStatus.classList.add("connected");
            startCallTimer();
          } else if (peerConnection.connectionState === "disconnected" || peerConnection.connectionState === "failed") {
            showToast("Call disconnected.");
            endCall();
          }
        };

        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        callChannel.publish("callUser", { to: selectedUserId, offer, callerName: userName }, (err) => {
          if (!err) {
            callInterfaceName.textContent = `Call with ${chatHeaderName.textContent}`;
            callInterface.classList.add("active");
          } else {
            showToast("Failed to initiate call: " + err.message);
            endCall();
          }
        });
      } catch (err) {
        showToast("Failed to start call: " + err.message);
        endCall();
      }
    });
  }

  if (acceptCall) {
    acceptCall.addEventListener("click", async () => {
      if (!callModal.dataset.callerId || !callModal.dataset.offer) {
        showToast("Invalid call data.");
        closeCallModal();
        return;
      }
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        peerConnection = new RTCPeerConnection(webrtcConfig);
        localStream.getTracks().forEach((track) => peerConnection.addTrack(track, localStream));

        peerConnection.ontrack = (event) => {
          remoteStream = event.streams[0];
          const audio = document.createElement("audio");
          audio.srcObject = remoteStream;
          audio.autoplay = true;
          document.body.appendChild(audio);
        };

        peerConnection.onicecandidate = (event) => {
          if (event.candidate) {
            callChannel.publish("iceCandidate", { to: callModal.dataset.callerId, candidate: event.candidate }, (err) => {
              if (err) {
                showToast("Failed to send ICE candidate: " + err.message);
              }
            });
          }
        };

        peerConnection.onconnectionstatechange = () => {
          if (peerConnection.connectionState === "connected" && callInterface && callStatus) {
            callStatus.textContent = "Connected";
            callStatus.classList.add("connected");
            startCallTimer();
          } else if (peerConnection.connectionState === "disconnected" || peerConnection.connectionState === "failed") {
            showToast("Call disconnected.");
            endCall();
          }
        };

        await peerConnection.setRemoteDescription(new RTCSessionDescription(JSON.parse(callModal.dataset.offer)));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        callChannel.publish("answerCall", { to: callModal.dataset.callerId, answer }, (err) => {
          if (err) {
            showToast("Failed to send answer: " + err.message);
            endCall();
          } else {
            callInterfaceName.textContent = `Call with ${callerName.textContent}`;
            callInterface.classList.add("active");
            closeCallModal();
          }
        });
      } catch (err) {
        showToast("Failed to accept call: " + err.message);
        endCall();
      }
    });
  }

  if (rejectCall) {
    rejectCall.addEventListener("click", () => {
      callChannel.publish("rejectCall", { to: callModal.dataset.callerId }, (err) => {
        if (err) {
          showToast("Failed to reject call: " + err.message);
        }
        closeCallModal();
      });
    });
  }

  if (muteButton) {
    muteButton.addEventListener("click", () => {
      if (localStream) {
        isMuted = !isMuted;
        localStream.getAudioTracks().forEach((track) => (track.enabled = !isMuted));
        muteButton.textContent = isMuted ? "Unmute" : "Mute";
        muteButton.classList.toggle("muted", isMuted);
      }
    });
  }

  if (endCallButton) {
    endCallButton.addEventListener("click", endCall);
  }

  // Ably Subscriptions
  userChannel.subscribe("userStatus", (msg) => {
    const { userId: senderId, status } = msg.data;
    const userItem = document.querySelector(`.user-item[data-user-id="${senderId}"]`);
    if (userItem) {
      const onlineStatus = userItem.querySelector(".online-status");
      if (onlineStatus) {
        onlineStatus.textContent = status ? "Online" : "Offline";
        onlineStatus.style.color = status ? "#22c55e" : "#6b7280";
      }
    }
  });

  messageChannel.subscribe("receiveMessage", async (msg) => {
    const { senderId, content, messageType, fileMetadata, tempMessageId } = msg.data;
    if (!sentMessageIds.has(tempMessageId) && selectedUserId === senderId) {
      try {
        const response = await fetch(`/api/messages?userId=${senderId}`, {
          headers: { Authorization: `Bearer ${token}` },
        });
        const msgData = await response.json();
        if (msgData.status === "success") {
          currentMessages = msgData.messages;
          displayMessages(currentMessages);
        }
      } catch (err) {
        showToast("Error fetching messages: " + err.message);
      }
    }
  });

  messageChannel.subscribe("messageStatus", (msg) => {
    const { messageId, status, isRead } = msg.data;
    updateMessageStatus(messageId, status, isRead);
  });

  callChannel.subscribe("callUser", (msg) => {
    const { to, offer, callerName: caller } = msg.data;
    if (to === userId && !peerConnection) {
      callerName.textContent = caller;
      callModal.dataset.callerId = msg.clientId;
      callModal.dataset.offer = JSON.stringify(offer);
      callModal.style.display = "flex";
    }
  });

  callChannel.subscribe("answerCall", async (msg) => {
    const { to, answer } = msg.data;
    if (to === userId && peerConnection) {
      try {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
      } catch (err) {
        showToast("Failed to set answer: " + err.message);
        endCall();
      }
    }
  });

  callChannel.subscribe("iceCandidate", async (msg) => {
    const { to, candidate } = msg.data;
    if (to === userId && peerConnection) {
      try {
        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
      } catch (err) {
        showToast("Failed to add ICE candidate: " + err.message);
      }
    }
  });

  callChannel.subscribe("rejectCall", (msg) => {
    const { to } = msg.data;
    if (to === userId) {
      showToast("Call rejected by user.");
      endCall();
    }
  });

  callChannel.subscribe("endCall", (msg) => {
    const { to } = msg.data;
    if (to === userId) {
      showToast("Call ended by user.");
      endCall();
    }
  });

  // Initial user list fetch
  async function fetchUsers() {
    try {
      const response = await fetch("/api/users", {
        headers: { Authorization: `Bearer ${token}` },
      });
      const data = await response.json();
      if (data.status === "success") {
        const adminUsers = data.users.filter((user) => user.role === "admin");
        updateUserList(adminUsers);
        if (selectedUserId) {
          const selectedUser = adminUsers.find((u) => u._id === selectedUserId);
          if (selectedUser) {
            document.querySelector(`.user-item[data-user-id="${selectedUserId}"]`)?.classList.add("selected");
            chatHeaderName.textContent = DOMPurify.sanitize(selectedUser.name);
            chatHeaderAvatar.src = DOMPurify.sanitize(selectedUser.profileImage);
            chatWindowContainer.classList.add("active");
            userListContainer.style.display = "none";
            const msgResponse = await fetch(`/api/messages?userId=${selectedUserId}`, {
              headers: { Authorization: `Bearer ${token}` },
            });
            const msgData = await msgResponse.json();
            if (msgData.status === "success") {
              currentMessages = msgData.messages;
              displayMessages(currentMessages);
            } else {
              showToast("Failed to fetch messages: " + msgData.message);
            }
          }
        }
      } else {
        showToast("Failed to fetch users: " + data.message);
      }
    } catch (err) {
      showToast("Error fetching users: " + err.message);
    }
  }

  fetchUsers();
});

    </script>
  </body>
</html>
